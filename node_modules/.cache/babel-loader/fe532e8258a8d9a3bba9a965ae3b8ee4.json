{"ast":null,"code":"import { Subject, from, queueScheduler } from 'rxjs';\nimport { map, mergeMap, observeOn, subscribeOn } from 'rxjs/operators';\nimport { ActionsObservable } from './ActionsObservable';\nimport { StateObservable } from './StateObservable';\nimport { warn } from './utils/console';\nexport function createEpicMiddleware() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // This isn't great. RxJS doesn't publicly export the constructor for\n  // QueueScheduler nor QueueAction, so we reach in. We need to do this because\n  // we don't want our internal queuing mechanism to be on the same queue as any\n  // other RxJS code outside of redux-observable internals.\n\n  var QueueScheduler = queueScheduler.constructor;\n  var uniqueQueueScheduler = new QueueScheduler(queueScheduler.SchedulerAction);\n\n  if (process.env.NODE_ENV !== 'production' && typeof options === 'function') {\n    throw new TypeError('Providing your root Epic to `createEpicMiddleware(rootEpic)` is no longer supported, instead use `epicMiddleware.run(rootEpic)`\\n\\nLearn more: https://redux-observable.js.org/MIGRATION.html#setting-up-the-middleware');\n  }\n\n  var epic$ = new Subject();\n  var store = void 0;\n\n  var epicMiddleware = function epicMiddleware(_store) {\n    if (process.env.NODE_ENV !== 'production' && store) {\n      // https://github.com/redux-observable/redux-observable/issues/389\n      warn('this middleware is already associated with a store. createEpicMiddleware should be called for every store.\\n\\nLearn more: https://goo.gl/2GQ7Da');\n    }\n\n    store = _store;\n    var actionSubject$ = new Subject().pipe(observeOn(uniqueQueueScheduler));\n    var stateSubject$ = new Subject().pipe(observeOn(uniqueQueueScheduler));\n    var action$ = new ActionsObservable(actionSubject$);\n    var state$ = new StateObservable(stateSubject$, store.getState());\n    var result$ = epic$.pipe(map(function (epic) {\n      var output$ = 'dependencies' in options ? epic(action$, state$, options.dependencies) : epic(action$, state$);\n\n      if (!output$) {\n        throw new TypeError('Your root Epic \"' + (epic.name || '<anonymous>') + '\" does not return a stream. Double check you\\'re not missing a return statement!');\n      }\n\n      return output$;\n    }), mergeMap(function (output$) {\n      return from(output$).pipe(subscribeOn(uniqueQueueScheduler), observeOn(uniqueQueueScheduler));\n    }));\n    result$.subscribe(store.dispatch);\n    return function (next) {\n      return function (action) {\n        // Downstream middleware gets the action first,\n        // which includes their reducers, so state is\n        // updated before epics receive the action\n        var result = next(action); // It's important to update the state$ before we emit\n        // the action because otherwise it would be stale\n\n        stateSubject$.next(store.getState());\n        actionSubject$.next(action);\n        return result;\n      };\n    };\n  };\n\n  epicMiddleware.run = function (rootEpic) {\n    if (process.env.NODE_ENV !== 'production' && !store) {\n      warn('epicMiddleware.run(rootEpic) called before the middleware has been setup by redux. Provide the epicMiddleware instance to createStore() first.');\n    }\n\n    epic$.next(rootEpic);\n  };\n\n  return epicMiddleware;\n}","map":{"version":3,"sources":["/home/dcestari/Documents/projects/react/react-pokeapi/.yarn/$$virtual/redux-observable-virtual-ded5a19f62/0/cache/redux-observable-npm-1.2.0-46cb237dc3-3.zip/node_modules/redux-observable/lib/esm/createEpicMiddleware.js"],"names":["Subject","from","queueScheduler","map","mergeMap","observeOn","subscribeOn","ActionsObservable","StateObservable","warn","createEpicMiddleware","options","arguments","length","undefined","QueueScheduler","constructor","uniqueQueueScheduler","SchedulerAction","process","env","NODE_ENV","TypeError","epic$","store","epicMiddleware","_store","actionSubject$","pipe","stateSubject$","action$","state$","getState","result$","epic","output$","dependencies","name","subscribe","dispatch","next","action","result","run","rootEpic"],"mappings":"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","sourcesContent":["import { Subject, from, queueScheduler } from 'rxjs';\nimport { map, mergeMap, observeOn, subscribeOn } from 'rxjs/operators';\nimport { ActionsObservable } from './ActionsObservable';\nimport { StateObservable } from './StateObservable';\nimport { warn } from './utils/console';\n\nexport function createEpicMiddleware() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  // This isn't great. RxJS doesn't publicly export the constructor for\n  // QueueScheduler nor QueueAction, so we reach in. We need to do this because\n  // we don't want our internal queuing mechanism to be on the same queue as any\n  // other RxJS code outside of redux-observable internals.\n  var QueueScheduler = queueScheduler.constructor;\n  var uniqueQueueScheduler = new QueueScheduler(queueScheduler.SchedulerAction);\n\n  if (process.env.NODE_ENV !== 'production' && typeof options === 'function') {\n    throw new TypeError('Providing your root Epic to `createEpicMiddleware(rootEpic)` is no longer supported, instead use `epicMiddleware.run(rootEpic)`\\n\\nLearn more: https://redux-observable.js.org/MIGRATION.html#setting-up-the-middleware');\n  }\n\n  var epic$ = new Subject();\n  var store = void 0;\n\n  var epicMiddleware = function epicMiddleware(_store) {\n    if (process.env.NODE_ENV !== 'production' && store) {\n      // https://github.com/redux-observable/redux-observable/issues/389\n      warn('this middleware is already associated with a store. createEpicMiddleware should be called for every store.\\n\\nLearn more: https://goo.gl/2GQ7Da');\n    }\n    store = _store;\n    var actionSubject$ = new Subject().pipe(observeOn(uniqueQueueScheduler));\n    var stateSubject$ = new Subject().pipe(observeOn(uniqueQueueScheduler));\n    var action$ = new ActionsObservable(actionSubject$);\n    var state$ = new StateObservable(stateSubject$, store.getState());\n\n    var result$ = epic$.pipe(map(function (epic) {\n      var output$ = 'dependencies' in options ? epic(action$, state$, options.dependencies) : epic(action$, state$);\n\n      if (!output$) {\n        throw new TypeError('Your root Epic \"' + (epic.name || '<anonymous>') + '\" does not return a stream. Double check you\\'re not missing a return statement!');\n      }\n\n      return output$;\n    }), mergeMap(function (output$) {\n      return from(output$).pipe(subscribeOn(uniqueQueueScheduler), observeOn(uniqueQueueScheduler));\n    }));\n\n    result$.subscribe(store.dispatch);\n\n    return function (next) {\n      return function (action) {\n        // Downstream middleware gets the action first,\n        // which includes their reducers, so state is\n        // updated before epics receive the action\n        var result = next(action);\n\n        // It's important to update the state$ before we emit\n        // the action because otherwise it would be stale\n        stateSubject$.next(store.getState());\n        actionSubject$.next(action);\n\n        return result;\n      };\n    };\n  };\n\n  epicMiddleware.run = function (rootEpic) {\n    if (process.env.NODE_ENV !== 'production' && !store) {\n      warn('epicMiddleware.run(rootEpic) called before the middleware has been setup by redux. Provide the epicMiddleware instance to createStore() first.');\n    }\n    epic$.next(rootEpic);\n  };\n\n  return epicMiddleware;\n}"]},"metadata":{},"sourceType":"module"}