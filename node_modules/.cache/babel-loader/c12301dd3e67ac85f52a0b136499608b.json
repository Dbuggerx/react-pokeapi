{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from '../Subject';\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nexport function windowTime(windowTimeSpan) {\n  var scheduler = async;\n  var windowCreationInterval = null;\n  var maxWindowSize = Number.POSITIVE_INFINITY;\n\n  if (isScheduler(arguments[3])) {\n    scheduler = arguments[3];\n  }\n\n  if (isScheduler(arguments[2])) {\n    scheduler = arguments[2];\n  } else if (isNumeric(arguments[2])) {\n    maxWindowSize = arguments[2];\n  }\n\n  if (isScheduler(arguments[1])) {\n    scheduler = arguments[1];\n  } else if (isNumeric(arguments[1])) {\n    windowCreationInterval = arguments[1];\n  }\n\n  return function windowTimeOperatorFunction(source) {\n    return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n  };\n}\n\nvar WindowTimeOperator = /*@__PURE__*/function () {\n  function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n    this.windowTimeSpan = windowTimeSpan;\n    this.windowCreationInterval = windowCreationInterval;\n    this.maxWindowSize = maxWindowSize;\n    this.scheduler = scheduler;\n  }\n\n  WindowTimeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n  };\n\n  return WindowTimeOperator;\n}();\n\nvar CountedSubject = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(CountedSubject, _super);\n\n  function CountedSubject() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._numberOfNextedValues = 0;\n    return _this;\n  }\n\n  CountedSubject.prototype.next = function (value) {\n    this._numberOfNextedValues++;\n\n    _super.prototype.next.call(this, value);\n  };\n\n  Object.defineProperty(CountedSubject.prototype, \"numberOfNextedValues\", {\n    get: function get() {\n      return this._numberOfNextedValues;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return CountedSubject;\n}(Subject);\n\nvar WindowTimeSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(WindowTimeSubscriber, _super);\n\n  function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.destination = destination;\n    _this.windowTimeSpan = windowTimeSpan;\n    _this.windowCreationInterval = windowCreationInterval;\n    _this.maxWindowSize = maxWindowSize;\n    _this.scheduler = scheduler;\n    _this.windows = [];\n\n    var window = _this.openWindow();\n\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n      var closeState = {\n        subscriber: _this,\n        window: window,\n        context: null\n      };\n      var creationState = {\n        windowTimeSpan: windowTimeSpan,\n        windowCreationInterval: windowCreationInterval,\n        subscriber: _this,\n        scheduler: scheduler\n      };\n\n      _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n\n      _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n    } else {\n      var timeSpanOnlyState = {\n        subscriber: _this,\n        window: window,\n        windowTimeSpan: windowTimeSpan\n      };\n\n      _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n    }\n\n    return _this;\n  }\n\n  WindowTimeSubscriber.prototype._next = function (value) {\n    var windows = this.windows;\n    var len = windows.length;\n\n    for (var i = 0; i < len; i++) {\n      var window_1 = windows[i];\n\n      if (!window_1.closed) {\n        window_1.next(value);\n\n        if (window_1.numberOfNextedValues >= this.maxWindowSize) {\n          this.closeWindow(window_1);\n        }\n      }\n    }\n  };\n\n  WindowTimeSubscriber.prototype._error = function (err) {\n    var windows = this.windows;\n\n    while (windows.length > 0) {\n      windows.shift().error(err);\n    }\n\n    this.destination.error(err);\n  };\n\n  WindowTimeSubscriber.prototype._complete = function () {\n    var windows = this.windows;\n\n    while (windows.length > 0) {\n      var window_2 = windows.shift();\n\n      if (!window_2.closed) {\n        window_2.complete();\n      }\n    }\n\n    this.destination.complete();\n  };\n\n  WindowTimeSubscriber.prototype.openWindow = function () {\n    var window = new CountedSubject();\n    this.windows.push(window);\n    var destination = this.destination;\n    destination.next(window);\n    return window;\n  };\n\n  WindowTimeSubscriber.prototype.closeWindow = function (window) {\n    window.complete();\n    var windows = this.windows;\n    windows.splice(windows.indexOf(window), 1);\n  };\n\n  return WindowTimeSubscriber;\n}(Subscriber);\n\nfunction dispatchWindowTimeSpanOnly(state) {\n  var subscriber = state.subscriber,\n      windowTimeSpan = state.windowTimeSpan,\n      window = state.window;\n\n  if (window) {\n    subscriber.closeWindow(window);\n  }\n\n  state.window = subscriber.openWindow();\n  this.schedule(state, windowTimeSpan);\n}\n\nfunction dispatchWindowCreation(state) {\n  var windowTimeSpan = state.windowTimeSpan,\n      subscriber = state.subscriber,\n      scheduler = state.scheduler,\n      windowCreationInterval = state.windowCreationInterval;\n  var window = subscriber.openWindow();\n  var action = this;\n  var context = {\n    action: action,\n    subscription: null\n  };\n  var timeSpanState = {\n    subscriber: subscriber,\n    window: window,\n    context: context\n  };\n  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n  action.add(context.subscription);\n  action.schedule(state, windowCreationInterval);\n}\n\nfunction dispatchWindowClose(state) {\n  var subscriber = state.subscriber,\n      window = state.window,\n      context = state.context;\n\n  if (context && context.action && context.subscription) {\n    context.action.remove(context.subscription);\n  }\n\n  subscriber.closeWindow(window);\n}","map":{"version":3,"sources":["../../../src/internal/operators/windowTime.ts"],"names":[],"mappings":";AAAA,OAAO,KAAE,OAAT,MAAwB,OAAxB;AAEA,SAAS,OAAT,QAAsB,YAAtB;AACA,SAAS,KAAT,QAAqB,oBAArB;AAGA,SAAS,UAAT,QAA0B,eAA1B;AACA,SAAS,SAAT,QAAsB,mBAAtB;AA+FA,SAAM,WAAN,QAA8B,qBAA9B;AACE,OAAA,SAAI,UAAJ,CAAqC,cAArC,EAAqC;AACrC,MAAI,SAAA,GAAA,KAAJ;AACA,MAAI,sBAA8B,GAAC,IAAnC;AAEA,MAAI,aAAY,GAAA,MAAU,CAAC,iBAA3B;;MACE,WAAS,CAAG,SAAS,CAAC,CAAD,CAAZ,C,EAAgB;AAC1B,IAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA;AAED;;MACE,WAAS,CAAG,SAAS,CAAC,CAAD,CAAZ,C,EAAgB;AAC1B,IAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA;AAAM,G,MACL,IAAA,SAAa,CAAA,SAAG,CAAS,CAAT,CAAH,CAAb,EAA6B;AAC9B,IAAA,aAAA,GAAA,SAAA,CAAA,CAAA,CAAA;AAED;;MACE,WAAS,CAAG,SAAS,CAAC,CAAD,CAAZ,C,EAAgB;AAC1B,IAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA;AAAM,G,MACL,IAAA,SAAA,CAAA,SAAsB,CAAG,CAAH,CAAtB,CAAA,EAAyB;AAC1B,IAAA,sBAAA,GAAA,SAAA,CAAA,CAAA,CAAA;AAED;;AACE,SAAA,SAAO,0BAAP,CAAuB,MAAvB,EAA6C;AAC7C,WAAA,MAAA,CAAA,IAAA,CAAA,IAAA,kBAAA,CAAA,cAAA,EAAA,sBAAA,EAAA,aAAA,EAAA,SAAA,CAAA,CAAA;AACH,GAFG;AAIJ;;IAEE,kBAAA,GAAA,aAAoB,YACA;AADA,WAAA,kBAAA,CAAA,cAAA,EAAsB,sBAAtB,EAAsB,aAAtB,EAAsB,SAAtB,EAAsB;AACtB,SAAA,cAAA,GAAA,cAAA;AACA,SAAA,sBAAA,GAAA,sBAAA;AACA,SAAA,aAAA,GAAA,aAAA;AACnB,SAAA,SAAA,GAAA,SAAA;AAED;;AACE,EAAA,kBAAc,CAAA,SAAd,CAAwB,IAAxB,GAA4B,UAAA,UAAA,EAC1B,MAD0B,EACd;AAEf,WAAA,MAAA,CAAA,SAAA,CAAA,IAAA,oBAAA,CAAA,UAAA,EAAA,KAAA,cAAA,EAAA,KAAA,sBAAA,EAAA,KAAA,aAAA,EAAA,KAAA,SAAA,CAAA,CAAA;AACH,GAJI;;AAIH,SAAA,kBAAA;AA0BD,CArCsB,E;;IAqCU,cAAA,GAAA,aAAA,UAAU,MAAV,EAAU;AAA1C,EAAA,OAAA,CAAA,SAAA,CAAA,cAAA,EAAA,MAAA;;AAAA,WAAA,cAAA,GAAA;AACU,QAAA,KAAA,GAAA,MAAA,KAAA,IAAA,IAAiC,MAAC,CAAA,KAAD,CAAC,IAAD,EAAC,SAAD,CAAjC,IAAkC,IAAlC;;;AAUT,WAAA,KAAA;AARC;;AACE,EAAA,cAAK,CAAA,SAAL,CAAK,IAAL,GAA4B,UAAC,KAAD,EAAC;AAC7B,SAAA,qBAAA;;AACD,IAAA,MAAA,CAAA,SAAA,CAAA,IAAA,CAAA,IAAA,CAAA,IAAA,EAAA,KAAA;AAED,GAJE;;SAIF,c,CAAA,cAAA,CAAA,S,EAAA,sB,EAAA;OACE,EAAA,eAAY;AACb,aAAA,KAAA,qBAAA;KAFD;oBAAA;AAEC,IAAA,YAAA,EAAA;AAFD,G;AAR8B,SAAO,cAAP;AAkBhC,CAlBgC,CAkBhC,OAlBgC,C;;IAkBM,oBAAA,GAAA,aAAA,UAAa,MAAb,EAAa;AAGjD,EAAA,OAAA,CAAA,SAAA,CAAA,oBAAA,EAAsB,MAAtB;;AAAA,WAAA,oBAAA,CAKE,WALF,EAKQ,cALR,EAiBC,sBAjBD,EAiBC,aAjBD,EAiBC,SAjBD,EAiBC;AAjBqB,QAAA,KAAA,GAAA,MAAW,CAAX,IAAA,CAAA,IAAA,EAAA,WAAA,KAAsC,IAAtC;;AACF,IAAA,KAAA,CAAA,WAAA,GAAA,WAAA;AACA,IAAA,KAAA,CAAA,cAAA,GAAA,cAAA;AACA,IAAA,KAAA,CAAA,sBAAA,GAAA,sBAAA;AACA,IAAA,KAAA,CAAA,aAAA,GAAA,aAAA;AANZ,IAAA,KAAA,CAAA,SAAA,GAAiC,SAAjC;AASN,IAAA,KAAM,CAAA,OAAN,GAAe,EAAf;;AACA,QAAI,MAAA,GAAA,KAAA,CAAA,UAAA,EAAJ;;QACE,sBAAoC,KAAA,IAApC,IAAgD,sBAAc,IAAO,C,EAAO;AAC5E,UAAM,UAAA,GAAa;AAAA,QAAA,UAAuB,EAAA,KAAvB;AAAqC,QAAA,MAAA,EAAA,MAArC;AAAuC,QAAA,OAAA,EAAA;AAAvC,OAAnB;AACA,UAAA,aAAS,GAAU;AAAA,QAAA,cAAwB,EAAA,cAAxB;AAA6C,QAAA,sBAA0B,EAAE,sBAAzE;AAA0E,QAAA,UAAA,EAAA,KAA1E;AAA0E,QAAA,SAAA,EAAA;AAA1E,OAAnB;;AACA,MAAA,KAAI,CAAC,GAAL,CAAS,SAAS,CAAC,QAAV,CAAqC,mBAArC,EAAqC,cAArC,EAA6D,UAA7D,CAAT;;AACD,MAAA,KAAA,CAAA,GAAA,CAAA,SAAA,CAAA,QAAA,CAAA,sBAAA,EAAA,sBAAA,EAAA,aAAA,CAAA;AAAM,K,MACL;AACA,UAAA,iBAAmB,GAAA;AAAA,QAAA,UAA+B,EAAA,KAA/B;AAA+B,QAAA,MAAA,EAAA,MAA/B;AAA2D,QAAA,cAAgB,EAAA;AAA3E,OAAnB;;AACD,MAAA,KAAA,CAAA,GAAA,CAAA,SAAA,CAAA,QAAA,CAAA,0BAAA,EAAA,cAAA,EAAA,iBAAA,CAAA;;;AACF,WAAA,KAAA;AAED;;AACE,EAAA,oBAAgB,CAAA,SAAhB,CAA6B,KAA7B,GAA6B,UAAA,KAAA,EAAA;AAC7B,QAAM,OAAM,GAAA,KAAQ,OAApB;AACA,QAAA,GAAK,GAAK,OAAO,CAAA,MAAjB;;AACE,SAAA,IAAM,CAAA,GAAA,CAAN,EAAY,CAAA,GAAG,GAAf,EAAe,CAAO,EAAtB,EAA0B;AAC1B,UAAI,QAAC,GAAO,OAAQ,CAAA,CAAA,CAApB;;UACE,CAAA,QAAO,CAAA,M,EAAK;AACZ,QAAA,QAAI,CAAA,IAAJ,CAAW,KAAX;;YACE,QAAK,CAAA,oBAAL,IAAyB,KAAA,a,EAAA;AAC1B,eAAA,WAAA,CAAA,QAAA;AACF;AACF;AACF;AAED,GAbE;;AAcA,EAAA,oBAAgB,CAAA,SAAhB,CAA6B,MAA7B,GAA6B,UAAA,GAAA,EAAA;AAC7B,QAAA,OAAO,GAAO,KAAC,OAAf;;AACE,WAAA,OAAQ,CAAA,MAAR,GAAgB,CAAhB,EAAsB;AACvB,MAAA,OAAA,CAAA,KAAA,GAAA,KAAA,CAAA,GAAA;AACD;;AACD,SAAA,WAAA,CAAA,KAAA,CAAA,GAAA;AAED,GAPE;;AAQA,EAAA,oBAAgB,CAAA,SAAhB,CAA6B,SAA7B,GAA6B,YAAA;AAC7B,QAAA,OAAO,GAAO,KAAC,OAAf;;AACE,WAAA,OAAM,CAAA,MAAN,GAAe,CAAf,EAAuB;AACvB,UAAI,QAAC,GAAO,OAAQ,CAAA,KAAR,EAAZ;;UACE,CAAA,QAAO,CAAA,M,EAAQ;AAChB,QAAA,QAAA,CAAA,QAAA;AACF;AACD;;AACD,SAAA,WAAA,CAAA,QAAA;AAED,GAVE;;AAWA,EAAA,oBAAe,CAAI,SAAnB,CAAmB,UAAnB,GAAuC,YAAA;AACvC,QAAI,MAAC,GAAQ,IAAI,cAAJ,EAAb;AACA,SAAM,OAAN,CAAM,IAAN,CAAoB,MAApB;AACA,QAAA,WAAY,GAAK,KAAM,WAAvB;AACA,IAAA,WAAO,CAAA,IAAP,CAAc,MAAd;AACD,WAAA,MAAA;AAED,GAPE;;AAQA,EAAA,oBAAe,CAAE,SAAjB,CAAkB,WAAlB,GAAkB,UAAA,MAAA,EAAA;AAClB,IAAA,MAAM,CAAA,QAAN;AACA,QAAA,OAAQ,GAAM,KAAC,OAAf;AACD,IAAA,OAAA,CAAA,MAAA,CAAA,OAAA,CAAA,OAAA,CAAA,MAAA,CAAA,EAAA,CAAA;AACH,GAJI;;AAhEkC,SAAA,oBAAA;AAsEtC,CAtEsC,CAsEtC,UAtEsC,C;;AAuE5B,SAAA,0BAAA,CAAA,KAAA,EAAY;AACpB,MAAI,UAAQ,GAAA,KAAA,CAAA,UAAZ;AAAA,MAAY,cAAA,GAAA,KAAA,CAAA,cAAZ;AAAA,MAAY,MAAA,GAAA,KAAA,CAAA,MAAZ;;MACE,M,EAAA;AACD,IAAA,UAAA,CAAA,WAAA,CAAA,MAAA;AACD;;AACA,EAAA,KAAK,CAAA,MAAL,GAAc,UAAO,CAAA,UAAP,EAAd;AACD,OAAA,QAAA,CAAA,KAAA,EAAA,cAAA;AAED;;AACU,SAAA,sBAAA,CAAA,KAAA,EAAA;AACR,MAAM,cAAS,GAAA,KAAW,CAAA,cAA1B;AAAA,MAAuC,UAAA,GAAA,KAAA,CAAA,UAAvC;AAAA,MAAuC,SAAA,GAAA,KAAA,CAAA,SAAvC;AAAA,MAAuC,sBAAA,GAAA,KAAA,CAAA,sBAAvC;AACA,MAAM,MAAM,GAAG,UAAK,CAAA,UAAL,EAAf;AACA,MAAI,MAAA,GAAO,IAAX;AACA,MAAM,OAAA,GAAA;AAAA,IAAA,MAAiC,EAAA,MAAjC;AAA2C,IAAA,YAAA,EAAE;AAA7C,GAAN;AACA,MAAA,aAAQ,GAAY;AAAA,IAAA,UAAY,EAAC,UAAb;AAAqC,IAAA,MAAA,EAAA,MAArC;AAAwD,IAAA,OAAE,EAAA;AAA1D,GAApB;AACA,EAAA,OAAO,CAAA,YAAP,GAAmB,SAAa,CAAC,QAAd,CAAc,mBAAd,EAAc,cAAd,EAAc,aAAd,CAAnB;AACA,EAAA,MAAM,CAAC,GAAP,CAAO,OAAS,CAAA,YAAhB;AACD,EAAA,MAAA,CAAA,QAAA,CAAA,KAAA,EAAA,sBAAA;AAED;;AACU,SAAA,mBAAA,CAAA,KAAA,EAAA;AACR,MAAI,UAAO,GAAI,KAAO,CAAC,UAAvB;AAAA,MAAiC,MAAQ,GAAA,KAAA,CAAA,MAAzC;AAAA,MAAuD,OAAA,GAAA,KAAA,CAAA,OAAvD;;MACE,OAAO,IAAC,OAAO,CAAA,MAAf,IAA6B,OAAC,CAAA,Y,EAAc;AAC7C,IAAA,OAAA,CAAA,MAAA,CAAA,MAAA,CAAA,OAAA,CAAA,YAAA;AACD;;AACD,EAAA,UAAA,CAAA,WAAA,CAAA,MAAA","sourcesContent":["/** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from '../Subject';\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nexport function windowTime(windowTimeSpan) {\n    var scheduler = async;\n    var windowCreationInterval = null;\n    var maxWindowSize = Number.POSITIVE_INFINITY;\n    if (isScheduler(arguments[3])) {\n        scheduler = arguments[3];\n    }\n    if (isScheduler(arguments[2])) {\n        scheduler = arguments[2];\n    }\n    else if (isNumeric(arguments[2])) {\n        maxWindowSize = arguments[2];\n    }\n    if (isScheduler(arguments[1])) {\n        scheduler = arguments[1];\n    }\n    else if (isNumeric(arguments[1])) {\n        windowCreationInterval = arguments[1];\n    }\n    return function windowTimeOperatorFunction(source) {\n        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n    };\n}\nvar WindowTimeOperator = /*@__PURE__*/ (function () {\n    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n    }\n    WindowTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n    };\n    return WindowTimeOperator;\n}());\nvar CountedSubject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(CountedSubject, _super);\n    function CountedSubject() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._numberOfNextedValues = 0;\n        return _this;\n    }\n    CountedSubject.prototype.next = function (value) {\n        this._numberOfNextedValues++;\n        _super.prototype.next.call(this, value);\n    };\n    Object.defineProperty(CountedSubject.prototype, \"numberOfNextedValues\", {\n        get: function () {\n            return this._numberOfNextedValues;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return CountedSubject;\n}(Subject));\nvar WindowTimeSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(WindowTimeSubscriber, _super);\n    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        var _this = _super.call(this, destination) || this;\n        _this.destination = destination;\n        _this.windowTimeSpan = windowTimeSpan;\n        _this.windowCreationInterval = windowCreationInterval;\n        _this.maxWindowSize = maxWindowSize;\n        _this.scheduler = scheduler;\n        _this.windows = [];\n        var window = _this.openWindow();\n        if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n            var closeState = { subscriber: _this, window: window, context: null };\n            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler };\n            _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n            _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n        }\n        else {\n            var timeSpanOnlyState = { subscriber: _this, window: window, windowTimeSpan: windowTimeSpan };\n            _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n        }\n        return _this;\n    }\n    WindowTimeSubscriber.prototype._next = function (value) {\n        var windows = this.windows;\n        var len = windows.length;\n        for (var i = 0; i < len; i++) {\n            var window_1 = windows[i];\n            if (!window_1.closed) {\n                window_1.next(value);\n                if (window_1.numberOfNextedValues >= this.maxWindowSize) {\n                    this.closeWindow(window_1);\n                }\n            }\n        }\n    };\n    WindowTimeSubscriber.prototype._error = function (err) {\n        var windows = this.windows;\n        while (windows.length > 0) {\n            windows.shift().error(err);\n        }\n        this.destination.error(err);\n    };\n    WindowTimeSubscriber.prototype._complete = function () {\n        var windows = this.windows;\n        while (windows.length > 0) {\n            var window_2 = windows.shift();\n            if (!window_2.closed) {\n                window_2.complete();\n            }\n        }\n        this.destination.complete();\n    };\n    WindowTimeSubscriber.prototype.openWindow = function () {\n        var window = new CountedSubject();\n        this.windows.push(window);\n        var destination = this.destination;\n        destination.next(window);\n        return window;\n    };\n    WindowTimeSubscriber.prototype.closeWindow = function (window) {\n        window.complete();\n        var windows = this.windows;\n        windows.splice(windows.indexOf(window), 1);\n    };\n    return WindowTimeSubscriber;\n}(Subscriber));\nfunction dispatchWindowTimeSpanOnly(state) {\n    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;\n    if (window) {\n        subscriber.closeWindow(window);\n    }\n    state.window = subscriber.openWindow();\n    this.schedule(state, windowTimeSpan);\n}\nfunction dispatchWindowCreation(state) {\n    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;\n    var window = subscriber.openWindow();\n    var action = this;\n    var context = { action: action, subscription: null };\n    var timeSpanState = { subscriber: subscriber, window: window, context: context };\n    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n    action.add(context.subscription);\n    action.schedule(state, windowCreationInterval);\n}\nfunction dispatchWindowClose(state) {\n    var subscriber = state.subscriber, window = state.window, context = state.context;\n    if (context && context.action && context.subscription) {\n        context.action.remove(context.subscription);\n    }\n    subscriber.closeWindow(window);\n}\n//# sourceMappingURL=windowTime.js.map\n"]},"metadata":{},"sourceType":"module"}